import asyncio
import os
from dotenv import load_dotenv
import random
import string
import re
import json
import aiohttp
from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler
)

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
CRYPTO_BOT_TOKEN = os.getenv("CRYPTO_BOT_TOKEN")
BOT_USERNAME = os.getenv("BOT_USERNAME")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
PORT = int(os.getenv("PORT", 8000))

CRYPTO_BOT_API_URL = "https://pay.crypt.bot/api"


def get_price_per_account(quantity):
    if 1 <= quantity < 20:
        return 10
    elif 20 <= quantity < 50:
        return 9
    elif 50 <= quantity <= 100:
        return 8
    else:
        return 10


async def create_crypto_invoice(amount: float, description: str, payload: str):
    url = f"{CRYPTO_BOT_API_URL}/createInvoice"
    
    headers = {
        'Crypto-Pay-API-Token': CRYPTO_BOT_TOKEN,
        'Content-Type': 'application/json'
    }
    
    data = {
        'asset': 'USDT',
        'amount': str(amount),
        'description': description,
        'payload': payload,
        'expires_in': 300
    }
    
    async with aiohttp.ClientSession() as session:
        async with session.post(url, headers=headers, json=data) as response:
            if response.status == 200:
                result = await response.json()
                if result.get('ok'):
                    return result['result']
                else:
                    error_msg = f"API Error: {result.get('error', {}).get('name', 'Unknown error')}"
                    raise Exception(error_msg)
            else:
                response_text = await response.text()
                error_msg = f"HTTP {response.status}: {response_text}"
                raise Exception(error_msg)


async def check_crypto_invoice(invoice_id: str):
    url = f"{CRYPTO_BOT_API_URL}/getInvoices"
    
    headers = {
        'Crypto-Pay-API-Token': CRYPTO_BOT_TOKEN,
        'Content-Type': 'application/json'
    }
    
    data = {
        'invoice_ids': [invoice_id]
    }
    
    async with aiohttp.ClientSession() as session:
        async with session.post(url, headers=headers, json=data) as response:
            if response.status == 200:
                try:
                    result = await response.json()
                    
                    if result.get('ok') and result.get('result') and result.get('result').get('items') and len(result['result']['items']) > 0:
                        invoice_data = result['result']['items'][0]
                        return invoice_data
                    else:
                        return {'status': 'not_found'}
                except json.JSONDecodeError as e:
                    return {'status': 'error', 'error': f'JSON decode error: {e}'}
                except Exception as parse_error:
                    return {'status': 'error', 'error': f'Parse error: {parse_error}'}
            else:
                response_text = await response.text()
                return {'status': 'error', 'error': f"HTTP {response.status}: {response_text}"}


async def check_invoice_timeout(update: Update, context: ContextTypes.DEFAULT_TYPE, invoice_id: str, message_id: int):
    await asyncio.sleep(300)
    
    invoice_data = await check_crypto_invoice(invoice_id)
    if invoice_data.get('status') != 'paid':
        try:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=message_id)
        except Exception:
            pass
        
        timeout_text = (
            "‚ùå –û–ø–ª–∞—Ç–∞ –Ω–µ –±—ã–ª–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞ –≤ —Ç–µ—á–µ–Ω–∏–µ 5 –º–∏–Ω—É—Ç.\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –ø–æ–∫—É–ø–∫–∏ –∑–∞–Ω–æ–≤–æ."
        )
        keyboard = [
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data='back_to_main_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=timeout_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )


def generate_credentials(quantity: int) -> str:
    credentials = []
    for i in range(quantity):
        login = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
        password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
        credentials.append(f"–ê–∫–∫–∞—É–Ω—Ç {i+1}: {login}: {password}")
    return "\n".join(credentials)


def get_main_menu_data():
    welcome_text = (
        "<b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Stripe Seller Bot ‚ú®</b>\n\n"
        "–î–∞–≤–Ω–æ —Ö–æ—Ç–µ–ª –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ Stripe –∞–∫–∫–∞—É–Ω—Ç—ã —Å "
        "–±–∞–ª–∞–Ω—Å–æ–º? –¢–µ–±–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ –∫ –Ω–∞–º! ‚≠ê\n\n"
        "–ù–∏–∂–µ —Ä–∞—Å–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è –º–µ–Ω—é, –æ–∑–Ω–∞–∫–æ–º–ª—è–π—Å—è üé≤"
    )

    keyboard = [
        [InlineKeyboardButton("–ö—É–ø–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç—ã üõí", callback_data='buy_accounts')],
        [
            InlineKeyboardButton("–ü–æ–¥–¥–µ—Ä–∂–∫–∞ üåê", callback_data='support'),
            InlineKeyboardButton("FAQ ‚ÜóÔ∏è", callback_data='faq')
        ],
        [InlineKeyboardButton("–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ üë•", callback_data='referral_system')],
        [InlineKeyboardButton("–ó–∞—Ä–∞–±–æ—Ç–∞—Ç—å üí∞", callback_data='earn_money')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    return welcome_text, reply_markup


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    welcome_text, reply_markup = get_main_menu_data()
    await update.message.reply_text(welcome_text, reply_markup=reply_markup, parse_mode='HTML')


async def referral_system_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    
    try:
        await query.answer()
    except Exception:
        pass
    
    user_id = query.from_user.id
    bot_username = BOT_USERNAME or "yourbot_username"
    referral_link = f"https://t.me/{bot_username}?start=ref_{user_id}"

    referral_text = (
        "üí∞ –ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π —Å –Ω–∞—à–µ–π —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–æ–π!\n"
        f"üîó –í–∞—à–∞ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\n"
        f"üëâ <code>{referral_link}</code>\n\n"
        "üéØ –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?\n"
        "‚úî –ü—Ä–∏–≥–ª–∞—à–∞–µ—à—å –¥—Ä—É–∑–µ–π ‚Äì –¥–µ–ª–∏—Å—å —Å–≤–æ–µ–π —Å—Å—ã–ª–∫–æ–π.\n"
        "‚úî –û–Ω–∏ –ø–æ–∫—É–ø–∞—é—Ç ‚Äì —Ç—ã –ø–æ–ª—É—á–∞–µ—à—å 5% –æ—Ç –∏—Ö –∑–∞–∫–∞–∑–∞.\n"
        "‚úî –ß–µ–º –±–æ–ª—å—à–µ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤ ‚Äì —Ç–µ–º –≤—ã—à–µ –ø–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥!\n\n"
        "üìä –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        "üî∏ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–æ: 0 —á–µ–ª–æ–≤–µ–∫\n"
        "üî∏ –î–æ—Ö–æ–¥ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: —Ä–∞—Å—Ç–µ—Ç —Å –∫–∞–∂–¥–æ–π –ø–æ–∫—É–ø–∫–æ–π!\n\n"
        "üöÄ –ù–∞—á–Ω–∏ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–æ–≤ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!\n\n"
        "<i>P.S. 10 –¥—Ä—É–∑–µ–π = –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ—Ñ–∏—Ç. –ê 50? –°—á–∏—Ç–∞–π —Å–∞–º! üòâ</i>"
    )
    keyboard = [
        [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back_to_main_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        await query.edit_message_text(
            text=referral_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )
    except Exception:
        await query.message.reply_text(
            text=referral_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )


async def buy_accounts_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    buy_text = (
        "–®–∞–≥ 1 –∏–∑ 3... –í—ã–±–æ—Ä –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–ª—è –ø–æ–∫—É–ø–∫–∏\n\n"
        "–†–µ—à–∏–ª –∫—É–ø–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç—ã? –¢—ã –Ω–∞ –≤–µ—Ä–Ω–æ–º –ø—É—Ç–∏! ‚úàÔ∏è\n"
        "–ù–∞—à–∏ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–µ—Ä–µ–¥ –¥—Ä—É–≥–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏:\n\n"
        "- –ú—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –≤–æ–∑–≤—Ä–∞—Ç –≤ —Å–ª—É—á–∞–µ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ üîÆ\n"
        "- –ì–æ—Ç–æ–≤—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –ø–ª–∞—Ç–µ–∂–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã –≤—ã—Å—à–µ–≥–æ —É—Ä–æ–≤–Ω—è üíæ\n"
        "- –£–¥–æ–±–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã üì•\n"
        "- –ë—ã—Å—Ç—Ä–∞—è —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞, –≥–æ—Ç–æ–≤–∞—è –≤–∞–º –ø–æ–º–æ—á—å –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç üìû\n\n"
        "–ö—Ö–º, –ø–µ—Ä–µ–π–¥–µ–º –∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É\n"
        "–í–æ—Ç –ø—Ä–∞–π—Å-–ª–∏—Å—Ç –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç—ãüíé\n\n"
        "–û—Ç 1 –¥–æ 20 –®—Ç—É–∫ - 10$üí∞\n"
        "–û—Ç 20 –¥–æ 50 –®—Ç—É–∫ - 9$üí∞\n"
        "–û—Ç 50 –¥–æ 100 –®—Ç—É–∫ - 8$üí∞\n\n"
        "–ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É —Å–≤–æ–µ –∫–æ–ª-–≤–æ —á—Ç–æ–±—ã –ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏ –∞–∫–∫–∞—É–Ω—Ç—ã –ª–∏–±–æ –≤—ã–±–µ—Ä–∏ –∏–∑ –≥–æ—Ç–æ–≤—ã—Ö –ø–∞–∫–æ–≤"
    )

    keyboard = [
        [InlineKeyboardButton("Lite Pack (1 –∞–∫–∫–∞—É–Ω—Ç)", callback_data='{"action": "select_pack", "quantity": 1}')],
        [InlineKeyboardButton("Starter Pack (3 –∞–∫–∫–∞—É–Ω—Ç–∞)", callback_data='{"action": "select_pack", "quantity": 3}')],
        [InlineKeyboardButton("Smart Pack (5 –∞–∫–∫–∞—É–Ω—Ç–æ–≤)", callback_data='{"action": "select_pack", "quantity": 5}')],
        [InlineKeyboardButton("Pro Pack (10 –∞–∫–∫–∞—É–Ω—Ç–æ–≤)", callback_data='{"action": "select_pack", "quantity": 10}')],
        [InlineKeyboardButton("Premium Pack (20 –∞–∫–∫–∞—É–Ω—Ç–æ–≤)", callback_data='{"action": "select_pack", "quantity": 20}')],
        [InlineKeyboardButton("Ultimate Pack (30 –∞–∫–∫–∞—É–Ω—Ç–æ–≤)", callback_data='{"action": "select_pack", "quantity": 30}')],
        [InlineKeyboardButton("–°–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ", callback_data='{"action": "select_custom_quantity"}')],
        [InlineKeyboardButton("–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data='back_to_buy_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        text=buy_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


def generate_order_id():
    order_id = ''.join(random.choices(string.digits, k=8))
    return order_id


async def handle_pack_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    try:
        data = json.loads(query.data)
        quantity = data.get('quantity')
    except json.JSONDecodeError:
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode='HTML')
        return
    
    price_per_item = get_price_per_account(quantity)
    total_price = quantity * price_per_item
    
    context.user_data['order'] = {
        'quantity': quantity,
        'total_price': total_price
    }

    order_text = (
        "–®–∞–≥ 2 –∏–∑ 3... –û–ø–ª–∞—Ç–∞ —Ç–æ–≤–∞—Ä–∞\n\n"
        "–¢—ã –ø–æ—á—Ç–∏ —É —Ü–µ–ª–∏ –≤–æ—Ç —Ç–≤–æ–π –∑–∞–∫–∞–∑, –≤—Å–µ –ª–∏ –≤–µ—Ä–Ω–æ? ‚úÖ\n"
        "üîπ –¢–æ–≤–∞—Ä: Stripe Accounts\n"
        f"üîπ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} —à—Ç—É–∫\n"
        f"üîπ –°—É–º–º–∞ –∑–∞–∫–∞–∑–∞: {total_price}$\n\n"
        "–ü–æ—á—Ç–∏ –≤—Å–µ –≥–æ—Ç–æ–≤–æ, –æ—Å—Ç–∞–ª–æ—Å—å –æ–ø–ª–∞—Ç–∏—Ç—å –∑–∞–∫–∞–∑, –≤—ã–±–µ—Ä–∏ –Ω–∏–∂–µ —Å–ø–æ—Å–æ–± –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è ‚úîÔ∏è"
    )
    
    keyboard = [
        [InlineKeyboardButton("üíé CryptoBot", callback_data='pay_cryptobot')],
        [InlineKeyboardButton("–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data='back_to_buy_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        text=order_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def handle_cryptobot_payment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    
    try:
        await query.answer()
    except Exception:
        pass

    order = context.user_data.get('order')
    if not order:
        await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.", parse_mode='HTML')
        return

    order_id = generate_order_id()
    quantity = order['quantity']
    total_price = order['total_price']
    
    context.user_data['order_id'] = order_id
    
    try:
        invoice_data = await create_crypto_invoice(
            amount=total_price,
            description=f"Stripe Accounts x{quantity}",
            payload=order_id
        )
        
        invoice_id = invoice_data.get('invoice_id')
        context.user_data['invoice_id'] = invoice_id
        context.user_data['invoice_time'] = datetime.now()
        
        payment_url = invoice_data.get('pay_url') or f"https://t.me/CryptoBot?start=IV{invoice_id}"
        
        cryptobot_text = (
            "–®–∞–≥ 2 –∏–∑ 3... –û–ø–ª–∞—Ç–∞ —Ç–æ–≤–∞—Ä–∞\n\n"
            "–†–µ—à–∏–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å CryptoBot? –ù–µ—Ç –ø—Ä–æ–±–ª–µ–º, –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–∏–∂–µ ‚¨áÔ∏è\n"
            f"üîπ ID –∑–∞–∫–∞–∑–∞: {order_id}\n"
            "üîπ –¢–æ–≤–∞—Ä: Stripe Accounts\n"
            f"üîπ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} —à—Ç—É–∫\n"
            f"üîπ –°—É–º–º–∞ –∑–∞–∫–∞–∑–∞: {total_price} USDT\n\n"
            "–í—Å–µ –≤–µ—Ä–Ω–æ? –í–Ω–∏–∑—É —Ç–µ–±—è –∂–¥–µ—Ç —Å—á–µ—Ç, –ø–æ—Å–ª–µ –µ–≥–æ –æ–ø–ª–∞—Ç—ã –∂–º–∏ –∫–Ω–æ–ø–∫—É –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É ‚è≠Ô∏è\n\n"
            "‚è∞ <b>–í–∞–∂–Ω–æ!</b> –°—á–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç!"
        )

        keyboard = [
            [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç—å —Å—á–µ—Ç", url=payment_url)],
            [InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É", callback_data='check_payment')],
            [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data='back_to_buy_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        try:
            message = await query.edit_message_text(
                text=cryptobot_text,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
            context.user_data['payment_message_id'] = message.message_id
            asyncio.create_task(check_invoice_timeout(update, context, invoice_id, message.message_id))
        except Exception:
            message = await query.message.reply_text(
                text=cryptobot_text,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
            context.user_data['payment_message_id'] = message.message_id
            asyncio.create_task(check_invoice_timeout(update, context, invoice_id, message.message_id))
        
    except Exception as e:
        error_text = (
            f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á–µ—Ç–∞.\n"
            f"–û—à–∏–±–∫–∞: {str(e)}\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
        )
        keyboard = [
            [InlineKeyboardButton("üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞", callback_data='pay_cryptobot')],
            [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥", callback_data='back_to_buy_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        try:
            await query.edit_message_text(
                text=error_text,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
        except Exception:
            await query.message.reply_text(
                text=error_text,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )


async def check_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    invoice_id = context.user_data.get('invoice_id')
    order_id = context.user_data.get('order_id')
    order = context.user_data.get('order')
    invoice_time = context.user_data.get('invoice_time')
    payment_message_id = context.user_data.get('payment_message_id')
    
    if not invoice_id or not order_id or not order or not invoice_time or not payment_message_id:
        try:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
        except Exception:
            pass
        await query.message.reply_text(
            "‚ùå –î–∞–Ω–Ω—ã–µ –æ –ø–ª–∞—Ç–µ–∂–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ù–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –æ–ø–ª–∞—Ç—ã –∑–∞–Ω–æ–≤–æ.",
            parse_mode='HTML'
        )
        return
    
    try:
        invoice_data = await check_crypto_invoice(invoice_id)
        
        if not invoice_data:
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
            except Exception:
                pass
            await query.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", parse_mode='HTML')
            return
        
        status = invoice_data.get('status')
        
        if status == 'paid':
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
            except Exception:
                pass
            credentials = generate_credentials(order['quantity'])
            success_text = (
                "‚úÖ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!\n"
                f"üì¶ –í–∞—à –∑–∞–∫–∞–∑ #{order_id}:\n"
                f"üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {order['quantity']} —à—Ç.\n"
                f"üí∞ –°—É–º–º–∞: {order['total_price']}$\n\n"
                "–í–∞—à–∏ –∞–∫–∫–∞—É–Ω—Ç—ã:\n"
                f"{credentials}\n\n"
                "‚ù§Ô∏è –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É, –ø—Ä–∏—è—Ç–µ–ª—å!"
            )
            
            keyboard = [
                [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back_to_main_menu')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.message.reply_text(
                text=success_text,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
        elif status == 'cancelled':
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
            except Exception:
                pass
            await query.message.reply_text("‚ùå –ü–ª–∞—Ç–µ–∂ –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω!", parse_mode='HTML')
        elif status == 'error':
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
            except Exception:
                pass
            await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–ª–∞—Ç–µ–∂–∞.", parse_mode='HTML')
        elif status == 'not_found':
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
            except Exception:
                pass
            await query.message.reply_text("‚ùå –ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω.", parse_mode='HTML')
        else:
            await query.message.reply_text("‚è≥ –û–ø–ª–∞—Ç–∞ –Ω–µ —Å–¥–µ–ª–∞–Ω–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!", parse_mode='HTML')
            
    except Exception:
        try:
            await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=payment_message_id)
        except Exception:
            pass
        await query.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.", parse_mode='HTML')


async def support_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    support_text = (
        "üÜò <b>–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞</b>\n\n"
        "–ï—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã? –ú—ã –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤—ã –ø–æ–º–æ—á—å!\n\n"
        "üìß –°–ø–æ—Å–æ–±—ã —Å–≤—è–∑–∏:\n"
        "‚Ä¢ Telegram: @Xvcen_Garant_BOT\n"
        "‚Ä¢ Email: Xvcen@Garant.com\n\n"
        "‚è∞ –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: 24/7\n"
        "‚ö° –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞: 5-15 –º–∏–Ω—É—Ç\n\n"
        "üî∏ –ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞–π–¥–µ—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª–µ FAQ"
    )
    
    keyboard = [
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data='back_to_main_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        text=support_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def faq_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    faq_text = (
        "‚ùì <b>–ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã</b>\n\n"
        "<b>Q:</b> –ö–∞–∫ –¥–æ–ª–≥–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã –∞–∫–∫–∞—É–Ω—Ç—ã?\n"
        "<b>A:</b> –í—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ —Ä–∞–±–æ—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è.\n\n"
        "<b>Q:</b> –ï—Å—Ç—å –ª–∏ –≥–∞—Ä–∞–Ω—Ç–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞?\n"
        "<b>A:</b> –î–∞, –º—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –≤–æ–∑–≤—Ä–∞—Ç –≤ —Å–ª—É—á–∞–µ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏.\n\n"
        "<b>Q:</b> –ö–∞–∫–∏–µ —Å–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã –¥–æ—Å—Ç—É–ø–Ω—ã?\n"
        "<b>A:</b> –ú—ã –ø—Ä–∏–Ω–∏–º–∞–µ–º –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ CryptoBot (USDT, BTC, ETH –∏ –¥—Ä.).\n\n"
        "<b>Q:</b> –°–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–Ω–∏–º–∞–µ—Ç –¥–æ—Å—Ç–∞–≤–∫–∞?\n"
        "<b>A:</b> –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã.\n\n"
        "<b>Q:</b> –ú–æ–∂–Ω–æ –ª–∏ –∫—É–ø–∏—Ç—å –±–æ–ª—å—à–µ 100 –∞–∫–∫–∞—É–Ω—Ç–æ–≤?\n"
        "<b>A:</b> –î–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –¥–ª—è –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è."
    )
    
    keyboard = [
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data='back_to_main_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        text=faq_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def earn_money_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    earn_text = (
        "üí∞ <b>–°–ø–æ—Å–æ–±—ã –∑–∞—Ä–∞–±–æ—Ç–∫–∞</b>\n\n"
        "1Ô∏è‚É£ <b>–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞</b>\n"
        "‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π 5% —Å –∫–∞–∂–¥–æ–π –ø–æ–∫—É–ø–∫–∏\n"
        "‚Ä¢ –ü–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π\n\n"
        "2Ô∏è‚É£ <b>–ü–∞—Ä—Ç–Ω–µ—Ä—Å–∫–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞</b>\n"
        "‚Ä¢ –î–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
        "‚Ä¢ –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è\n"
        "‚Ä¢ –û–±—Ä–∞—â–∞–π—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É\n\n"
        "3Ô∏è‚É£ <b>–û–ø—Ç–æ–≤—ã–µ –∑–∞–∫—É–ø–∫–∏</b>\n"
        "‚Ä¢ –ü–æ–∫—É–ø–∞–π –æ–ø—Ç–æ–º - –ø—Ä–æ–¥–∞–≤–∞–π –≤ —Ä–æ–∑–Ω–∏—Ü—É\n"
        "‚Ä¢ –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã –æ—Ç 100+ –∞–∫–∫–∞—É–Ω—Ç–æ–≤\n\n"
        "üí° <b>–ù–∞—á–Ω–∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —É–∂–µ —Å–µ–≥–æ–¥–Ω—è!</b>"
    )
    
    keyboard = [
        [InlineKeyboardButton("üë• –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞", callback_data='referral_system')],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data='back_to_main_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        text=earn_text,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )


async def back_to_buy_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await buy_accounts_handler(update, context)


async def back_to_main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    
    try:
        await query.answer()
    except Exception:
        pass
    
    welcome_text, reply_markup = get_main_menu_data()

    try:
        await query.edit_message_text(
            text=welcome_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )
    except Exception:
        await query.message.reply_text(
            text=welcome_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )


def main() -> None:
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(buy_accounts_handler, pattern='^buy_accounts$'))
    application.add_handler(CallbackQueryHandler(support_handler, pattern='^support$'))
    application.add_handler(CallbackQueryHandler(faq_handler, pattern='^faq$'))
    application.add_handler(CallbackQueryHandler(referral_system_handler, pattern='^referral_system$'))
    application.add_handler(CallbackQueryHandler(earn_money_handler, pattern='^earn_money$'))
    
    application.add_handler(CallbackQueryHandler(handle_pack_selection, pattern=re.compile(r'^\{"action": "select_pack".*')))
    application.add_handler(CallbackQueryHandler(handle_cryptobot_payment, pattern='^pay_cryptobot$'))
    application.add_handler(CallbackQueryHandler(check_payment_handler, pattern='^check_payment$'))
    
    application.add_handler(CallbackQueryHandler(back_to_buy_menu_handler, pattern='^back_to_buy_menu$'))
    application.add_handler(CallbackQueryHandler(back_to_main_menu_handler, pattern='^back_to_main_menu$'))
    
    if WEBHOOK_URL:
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=BOT_TOKEN,
            webhook_url=f"{WEBHOOK_URL}/{BOT_TOKEN}"
        )
    else:
        application.run_polling()


if __name__ == '__main__':
    main()